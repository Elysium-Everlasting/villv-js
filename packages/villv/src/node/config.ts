import fs from 'node:fs'
import path from 'node:path'
// import util from 'node:util'
import type {
  InputOption,
  ModuleFormat,
  ObjectHook,
  RollupOptions,
  Plugin as RollupPlugin,
  WatcherOptions,
} from 'rollup'
import colors from 'picocolors'
import type { BuildOptions as ESBuildOptions, TransformOptions } from 'esbuild'
import type { Alias } from '@rollup/plugin-alias'
import type { RollupDynamicImportVariablesOptions } from '@rollup/plugin-dynamic-import-vars'
import type { RollupCommonJSOptions } from '@rollup/plugin-commonjs'
import type Terser from 'terser'
import {
  CLIENT_ENTRY,
  DEFAULT_ASSETS_REGEX,
  DEFAULT_CONFIG_FILES,
  DEFAULT_EXTENSIONS,
  DEFAULT_MAIN_FIELDS,
  ENV_ENTRY,
  ENV_PREFIX,
  ESBUILD_MODULES_TARGET,
  FS_PREFIX,
} from './constants.js'
import { createLogger, type Logger, type LogLevel } from './logger.js'
import {
  asyncFlatten,
  createDebugger,
  createFilter,
  isExternalUrl,
  isObject,
  lookupFile,
  mergeAlias,
  mergeConfig,
  normalizeAlias,
  normalizePath,
  requireResolveFromRootWithFallback,
} from './utils.js'
import { loadEnv, resolveEnvPrefix } from './env.js'
import { findNearestPackageData, type PackageCache } from './packages.js'

const debug = createDebugger('vite:config')
// const promisifiedRealpath = util.promisify(fs.realpath)

/**
 * TODO
 */
export interface Plugin extends RollupPlugin {
  /**
   * Enforce plugin invocation tier similar to webpack loaders.
   *
   * Plugin invocation order:
   * - alias resolution
   * - `enforce: 'pre'` plugins
   * - vite core plugins
   * - normal plugins
   * - vite build plugins
   * - `enforce: 'post'` plugins
   * - vite build post plugins
   */
  enforce?: 'pre' | 'post'

  /**
   * Apply the plugin only for serve or build, or on certain conditions.
   */
  apply?: ConfigCommand | ((this: void, config: UserConfig, env: ConfigEnv) => boolean)

  /**
   * Modify vite config before it's resolved.
   *
   * The hook can either mutate the passed-in config directly,
   * or return a partial config object that will be deeply merged into existing config.
   *
   * Note: User plugins are resolved before running this hook so injecting other
   * plugins inside  the `config` hook will have no effect.
   */
  config?: ObjectHook<(this: void, config: UserConfig, env: ConfigEnv) => ModifiedConfigResult>

  /**
   * Perform custom handling of HMR updates.
   * The handler receives a context containing changed filename, timestamp, a
   * list of modules affected by the file change, and the dev server instance.
   *
   * - The hook can return a filtered list of modules to narrow down the update.
   *   e.g. for a Vue SFC, we can narrow down the part to update by comparing
   *   the descriptors.
   *
   * - The hook can also return an empty array and then perform custom updates
   *   by sending a custom hmr payload via server.ws.send().
   *
   * - If the hook doesn't return a value, the hmr update will be performed as
   *   normal.
   */
  handleHotUpdate?: ObjectHook<
    (this: void, ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>
  >
}

/**
 * TODO
 */
interface HmrContext {
  file: string
  timestamp: number
}

/**
 * TODO
 */
interface ModuleNode {}

type ModifiedConfigResult = UserConfig | null | void | Promise<UserConfig | null | void>

export type UserConfig = {
  /**
   * Project root directory.
   *
   * Can be an absolute path, or a path relative from the location of the config file itself.
   *
   * @default process.cwd()
   */
  root?: string

  /**
   * Base public path when served in development or production.
   *
   * @default '/'
   */
  base?: string

  /**
   * Directory to serve as plain static assets.
   *
   * Files in this directory are served and copied to build dist dir as-is without transformations.
   * The value can be either an absolute file system path or a path relative to project root.
   *
   * Set to `false` or an empty string to disable copied static assets to build dist dir.
   *
   * @default 'public'
   */
  publicDirectory?: string | false

  /**
   * Directory to save cache files.
   *
   * Files in this directory are pre-bundled deps or some other cache files
   * that generated by vite, which can improve the performance.
   *
   * You can use `--force` flag or manually delete the directory to regenerate the cache files.
   * The value can be either an absolute file system path or a path relative to project root.
   *
   * Default to `.vite` when no `package.json` is detected.
   *
   * @default 'node_modules/.vite'
   */
  cacheDirectory?: string

  /**
   * Explicitly set a mode to run in.
   *
   * This will override the default mode for each command,
   * and can be overridden by the command line --mode option.
   */
  mode?: string

  /**
   * Define global variable replacements.
   *
   * Entries will be defined on `window` during dev and replaced during build.
   */
  define?: Record<PropertyKey, any>

  /**
   * Array of vite plugins to use.
   */
  plugins?: PluginOption[]

  /**
   * Configure resolver
   *
   * TODO
   */
  resolve?: any // ResolveOptions & { alias?: AliasOptions }

  /**
   * CSS related options (preprocessors and CSS modules)
   *
   * TODO
   */
  css?: any // CSSOptions

  /**
   * JSON loading options
   *
   * TODO
   */
  json?: any // JsonOptions

  /**
   * Transform options to pass to esbuild.
   * Or set to `false` to disable esbuild.
   */
  esbuild?: ESBuildOptions | false

  /**
   * Specify additional picomatch patterns to be treated as static assets.
   */
  assetsInclude?: string | RegExp | (string | RegExp)[]

  /**
   * Server specific options, e.g. host, port, https...
   *
   * TODO
   */
  server?: any // ServerOptions

  /**
   * Build specific options
   *
   * TODO
   */
  build?: any // BuildOptions

  /**
   * Preview specific options, e.g. host, port, https...
   *
   * TODO
   */
  preview?: any // PreviewOptions

  /**
   * Dep optimization options
   *
   * TODO
   */
  optimizeDeps?: any // DepOptimizationOptions

  /**
   * SSR specific options
   *
   * TODO
   */
  ssr?: any // SSROptions

  /**
   * Experimental features
   *
   * Features under this field could change in the future and might NOT follow semver.
   * Please be careful and always pin Vite's version when using them.
   *
   * @experimental
   */
  experimental?: ExperimentalOptions

  /**
   * Legacy options.
   *
   * Features under this field only follow semver for patches,
   * they could be removed in a future minor version.
   *
   * Please always pin Vite's version to a minor when using them.
   */
  legacy?: LegacyOptions

  /**
   * Log level.
   *
   * @default 'info'
   */
  logLevel?: LogLevel

  /**
   * Custom logger.
   */
  customLogger?: Logger

  /**
   * @default true
   */
  clearScreen?: boolean

  /**
   * Environment files directory.
   *
   * Can be an absolute path, or a path relative from root.
   *
   * @default root
   */
  envDirectory?: string

  /**
   * Env variables starts with `envPrefix` will be exposed to your client source code via import.meta.env.
   *
   * @default {@link ENV_PREFIX}
   */
  envPrefix?: string

  /**
   * Worker bundle options.
   */
  worker?: WorkerBundleOptions

  /**
   * Whether your application is a:
   * - Single Page Application (SPA)
   * - Multi-Page Application (MPA)
   * - Custom Application (SSR and frameworks with custom HTML handling)
   *
   * @default 'spa'
   */
  appType?: AppType
}

type Override<Left, Right> = Omit<Left, keyof Right> & Right

type InternalConfig = {
  configFile: string | undefined

  configFileDependencies: string[]

  inlineConfig: InlineConfig

  root: string

  base: string

  /**
   * @internal
   */
  rawBase: string

  publicDir: string

  cacheDir: string

  command: ConfigCommand

  mode: string

  isWorker: boolean

  /**
   * In nested worker bundle to find the main config.
   * @internal
   */
  mainConfig: ResolvedConfig | null

  isProduction: boolean

  envDir: string

  env: Record<string, any>

  resolve: Required<ResolveOptions> & { alias: Alias[] }

  plugins: readonly Plugin[]

  /**
   * TODO
   */
  css: any // ResolvedCSSOptions | undefined

  esbuild: ESBuildOptions | false

  /**
   * TODO
   */
  server: any // ResolvedServerOptions

  /**
   * TODO
   */
  build: any // ResolvedBuildOptions

  /**
   * TODO
   */
  preview: any // ResolvedPreviewOptions

  /**
   * TODO
   */
  ssr: any // ResolvedSSROptions

  assetsInclude: (file: string) => boolean

  logger: Logger

  /**
   * TODO
   */
  createResolver: any // (options?: Partial<InternalResolveOptions>) => ResolveFn

  /**
   * TODO
   */
  optimizeDeps: any // DepOptimizationOptions

  /**
   * @internal
   *
   * TODO
   */
  packageCache: any // PackageCache

  /**
   * TODO
   */
  worker: any // ResolveWorkerOptions

  appType: AppType

  experimental: ExperimentalOptions
}

export type ResolvedConfig = Override<UserConfig, InternalConfig & PluginHookUtils>

/**
 */
export interface InlineConfig extends UserConfig {
  configFile?: string | false
  envFile?: false
}

/**
 * TODO: move somewhere else?
 */
export interface ResolveOptions {
  /**
   * Idk. What are browser or main fields??
   *
   * @default ['module', 'jsnext:main', 'jsnext']
   */
  mainFields?: string[]

  /**
   * @deprecated In future, `mainFields` should be used instead.
   *
   * @default true
   */
  browserField?: boolean

  /**
   * Idk.
   */
  conditions?: string[]

  /**
   * Idk.
   *
   * @default ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']
   */
  extensions?: string[]

  /**
   * Idk.
   */
  dedupe?: string[]

  /**
   * Idk.
   *
   * @default false
   */
  preserveSymlinks?: boolean
}

/**
 */
export interface PluginHookUtils {
  getSortedPlugins(hookName: keyof Plugin): Plugin[]
  getSortedPluginHooks<K extends keyof Plugin>(hookName: K): NonNullable<HookHandler<Plugin[K]>>[]
}

/**
 * TODO: move this somewhere else?
 */
export type HookHandler<T> = T extends ObjectHook<infer H> ? H : T

/**
 * Environment that the config is being executed in.
 */
export interface ConfigEnv {
  /**
   * The command used to invoke the config.
   */
  command: ConfigCommand

  /**
   * @example 'prod', 'local'
   */
  mode: string

  /**
   * @experimental
   */
  ssrBuild?: boolean
}

export interface WorkerBundleOptions {
  /**
   * Output format for worker bundle
   * @default 'iife'
   */
  format?: WorkerBundleFormat

  /**
   * Vite plugins that apply to worker bundle
   */
  plugins?: PluginOption[]

  /**
   * Rollup options to build worker bundle
   */
  rollupOptions?: Omit<RollupOptions, 'plugins' | 'input' | 'onwarn' | 'preserveEntrySignatures'>
}

export type WorkerBundleFormat = 'es' | 'iife'

export type ConfigCommand = 'build' | 'serve'

/**
 * spa: Include SPA fallback middleware and configure sirv with `single: true` in preview.
 *
 * mpa: Only include non-SPA HTML middlewares.
 *
 * custom: Don't include HTML middlewares.
 */
export type AppType = 'spa' | 'mpa' | 'custom'

export type UserConfigFn = (env: ConfigEnv) => UserConfig | Promise<UserConfig>

export type UserConfigExport = ReturnType<UserConfigFn> | UserConfigFn

export type PluginOption =
  | Plugin
  | false
  | null
  | undefined
  | PluginOption[]
  | Promise<PluginOption>

/**
 * TODO
 */
export interface LegacyOptions {}

/**
 * TODO
 */
export interface ExperimentalOptions {}

/**
 * Type helper to make it easier to use vite.config.ts
 *
 * Accepts a direct {@link UserConfig} object, or a function that returns it.
 *
 * The function receives a {@link ConfigEnv} object.
 */
export function defineConfig<T extends UserConfigExport>(config: T): T {
  return config
}

export async function resolveConfig(
  inlineConfig: InlineConfig,
  command: ConfigCommand,
  defaultMode = 'development',
  defaultNodeEnv = 'development',
): Promise<ResolvedConfig> {
  let config = inlineConfig
  let configFileDependencies: string[] = []
  let mode = inlineConfig.mode ?? defaultMode

  const isNodeEnvSet = !!process.env['NODE_ENV']
  const packageCache: PackageCache = new Map()

  /**
   * Some dependencies e.g. @vue/compiler-* relies on NODE_ENV
   * for getting production-specific behavior, so set it early on.
   */
  if (!isNodeEnvSet) {
    process.env['NODE_ENV'] = defaultNodeEnv
  }

  const configEnv = {
    mode,
    command,
    ssrBuild: !!config.build?.ssr,
  }

  let { configFile, root } = config

  if (configFile !== false) {
    await loadConfigFromFile({ configFile, configEnv, root }, config.logLevel).then(
      (loadResult) => {
        if (loadResult) {
          config = mergeConfig(loadResult.config, config)
          configFile = loadResult.path
          configFileDependencies = loadResult.dependencies
        }
      },
    )
  }

  /**
   * User config may provide an alternative mode. But --mode has a higher priority.
   */
  configEnv.mode = inlineConfig.mode ?? config.mode ?? mode

  const filterPlugin = (p: Plugin) => {
    if (!p) {
      return false
    } else if (!p.apply) {
      return true
    } else if (typeof p.apply === 'function') {
      return p.apply({ ...config, mode }, configEnv)
    } else {
      return p.apply === command
    }
  }

  /**
   * Some plugins that aren't intended to work in the bundling of workers (doing post-processing at build time for example).
   * And Plugins may also have cached that could be corrupted by being used in these extra rollup calls.
   * So we need to separate the worker plugin from the plugin that vite needs to run.
   */
  const rawWorkerUserPlugins = await asyncFlatten(config.worker?.plugins ?? []).then((plugins) =>
    (plugins as Plugin[]).filter(filterPlugin),
  )

  /**
   * Resolve plugins.
   */
  const rawUserPlugins = await asyncFlatten(config.plugins ?? []).then((plugins) =>
    (plugins as Plugin[]).filter(filterPlugin),
  )

  const [prePlugins, normalPlugins, postPlugins] = sortUserPlugins(rawUserPlugins)

  /**
   * Run config hooks.
   */
  const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins]

  config = await runConfigHook(config, userPlugins, configEnv)

  /**
   * If there are custom commonjsOptions, don't force optimized deps for this test ---
   * even if the env var is set as it would interfere with the playground specs.
   */
  if (!config.build?.commonjsOptions && process.env['VITE_TEST_WITHOUT_PLUGIN_COMMONJS']) {
    config = mergeConfig(config, {
      optimizeDeps: { disabled: false },
      ssr: { optimizeDeps: { disabled: false } },
    })
    config.build ??= {}
    config.build.commonjsOptions = { include: [] }
  }

  /**
   * Define logger.
   */
  const logger = createLogger(config.logLevel, {
    allowClearScreen: config.clearScreen,
    customLogger: config.customLogger,
  })

  /**
   * Resolve root.
   */
  const resolvedRoot = normalizePath(config.root ? path.resolve(config.root) : process.cwd())

  const clientAlias = [
    {
      find: /^\/?@vite\/env/,
      replacement: path.posix.join(FS_PREFIX, normalizePath(ENV_ENTRY)),
    },
    {
      find: /^\/?@vite\/client/,
      replacement: path.posix.join(FS_PREFIX, normalizePath(CLIENT_ENTRY)),
    },
  ]

  // resolve alias with internal client alias
  const resolvedAlias = normalizeAlias(mergeAlias(clientAlias, config.resolve?.alias || []))

  const resolveOptions: ResolvedConfig['resolve'] = {
    mainFields: config.resolve?.mainFields ?? DEFAULT_MAIN_FIELDS,
    browserField: config.resolve?.browserField ?? true,
    conditions: config.resolve?.conditions ?? [],
    extensions: config.resolve?.extensions ?? DEFAULT_EXTENSIONS,
    dedupe: config.resolve?.dedupe ?? [],
    preserveSymlinks: config.resolve?.preserveSymlinks ?? false,
    alias: resolvedAlias,
  }

  /**
   * Load .env files.
   */
  const envDir = config.envDirectory
    ? normalizePath(path.resolve(resolvedRoot, config.envDirectory))
    : resolvedRoot

  const userEnv = inlineConfig.envFile !== false && loadEnv(mode, envDir, resolveEnvPrefix(config))

  /**
   * Note it is possible for user to have a custom mode,
   *
   * e.g. `staging` where development-like behavior is expected.
   *
   * This is indicated by NODE_ENV=development loaded from `.staging.env` and set by us as VITE_USER_NODE_ENV
   */
  const userNodeEnv = process.env['VITE_USER_NODE_ENV']

  if (!isNodeEnvSet && userNodeEnv) {
    if (userNodeEnv === 'development') {
      process.env['NODE_ENV'] = 'development'
    } else {
      /**
       * NODE_ENV=production is not supported as it could break HMR in dev for frameworks like Vue
       */
      logger.warn(
        `NODE_ENV=${userNodeEnv} is not supported in the .env file. ` +
          `Only NODE_ENV=development is supported to create a development build of your project. ` +
          `If you need to set process.env.NODE_ENV, you can set it in the Vite config instead.`,
      )
    }
  }

  const isProduction = process.env['NODE_ENV'] === 'production'

  /**
   * Resolve public base url.
   */
  const isBuild = command === 'build'

  const relativeBaseShortcut = config.base === '' || config.base === './'

  /**
   * During dev, we ignore relative base and fallback to '/'
   *
   * For the SSR build, relative base isn't possible by means of import.meta.url.
   */
  const resolvedBase = relativeBaseShortcut
    ? !isBuild || config.build?.ssr
      ? '/'
      : './'
    : resolveBaseUrl(config.base, isBuild, logger) ?? '/'

  const resolvedBuildOptions = resolveBuildOptions(config.build, logger, resolvedRoot)

  /**
   * Resolve cache directory.
   */
  const pkgDir = findNearestPackageData(resolvedRoot, packageCache)?.dir

  const cacheDir = normalizePath(
    config.cacheDirectory
      ? path.resolve(resolvedRoot, config.cacheDirectory)
      : pkgDir
      ? path.join(pkgDir, `node_modules/.vite`)
      : path.join(resolvedRoot, `.vite`),
  )

  const assetsFilter =
    config.assetsInclude && (!Array.isArray(config.assetsInclude) || config.assetsInclude.length)
      ? createFilter(config.assetsInclude)
      : () => false

  /**
   * Create an internal resolver to be used in special scenarios
   *
   * e.g. optimizer & handling css @imports
   */
  const createResolver: ResolvedConfig['createResolver'] = (options) => {
    let aliasContainer: PluginContainer | undefined
    let resolverContainer: PluginContainer | undefined

    return async (id, importer, aliasOnly, ssr) => {
      let container: PluginContainer

      if (aliasOnly) {
        container =
          aliasContainer ||
          (aliasContainer = await createPluginContainer({
            ...resolved,
            plugins: [aliasPlugin({ entries: resolved.resolve.alias })],
          }))
      } else {
        container =
          resolverContainer ||
          (resolverContainer = await createPluginContainer({
            ...resolved,
            plugins: [
              aliasPlugin({ entries: resolved.resolve.alias }),
              resolvePlugin({
                ...resolved.resolve,
                root: resolvedRoot,
                isProduction,
                isBuild: command === 'build',
                ssrConfig: resolved.ssr,
                asSrc: true,
                preferRelative: false,
                tryIndex: true,
                ...options,
                idOnly: true,
              }),
            ],
          }))
      }

      return (await container.resolveId(id, importer, { ssr, scan: options?.scan }))?.id
    }
  }

  const { publicDirectory } = config

  const resolvedPublicDir =
    publicDirectory !== false && publicDirectory !== ''
      ? path.resolve(resolvedRoot, typeof publicDirectory === 'string' ? publicDirectory : 'public')
      : ''

  const server = resolveServerOptions(resolvedRoot, config.server, logger)

  const ssr = resolveSSROptions(
    config.ssr,
    resolveOptions.preserveSymlinks,
    config.legacy?.buildSsrCjsExternalHeuristics,
  )

  const middlewareMode = config?.server?.middlewareMode

  const optimizeDeps = config.optimizeDeps || {}

  const BASE_URL = resolvedBase

  /**
   * Resolve worker.
   */
  let workerConfig = mergeConfig({}, config)

  const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] =
    sortUserPlugins(rawWorkerUserPlugins)

  /**
   * Run config hooks.
   */
  const workerUserPlugins = [...workerPrePlugins, ...workerNormalPlugins, ...workerPostPlugins]

  workerConfig = await runConfigHook(workerConfig, workerUserPlugins, configEnv)

  const resolvedWorkerOptions: ResolveWorkerOptions = {
    format: workerConfig.worker?.format || 'iife',
    plugins: [],
    rollupOptions: workerConfig.worker?.rollupOptions || {},
    getSortedPlugins: undefined!,
    getSortedPluginHooks: undefined!,
  }

  const resolvedConfig: ResolvedConfig = {
    configFile: configFile ? normalizePath(configFile) : undefined,
    configFileDependencies: configFileDependencies.map((name) => normalizePath(path.resolve(name))),
    inlineConfig,
    root: resolvedRoot,
    base: resolvedBase.endsWith('/') ? resolvedBase : resolvedBase + '/',
    rawBase: resolvedBase,
    resolve: resolveOptions,
    publicDir: resolvedPublicDir,
    cacheDir,
    command,
    mode,
    ssr,
    isWorker: false,
    mainConfig: null,
    isProduction,
    plugins: userPlugins,
    css: resolveCSSOptions(config.css),
    esbuild:
      config.esbuild === false
        ? false
        : {
            jsxDev: !isProduction,
            ...config.esbuild,
          },
    server,
    build: resolvedBuildOptions,
    preview: resolvePreviewOptions(config.preview, server),
    envDir,
    env: {
      ...userEnv,
      BASE_URL,
      MODE: mode,
      DEV: !isProduction,
      PROD: isProduction,
    },
    assetsInclude(file: string) {
      return DEFAULT_ASSETS_REGEX.test(file) || assetsFilter(file)
    },
    logger,
    packageCache,
    createResolver,
    optimizeDeps: {
      disabled: 'build',
      ...optimizeDeps,
      esbuildOptions: {
        preserveSymlinks: resolveOptions.preserveSymlinks,
        ...optimizeDeps.esbuildOptions,
      },
    },
    worker: resolvedWorkerOptions,
    appType: config.appType ?? (middlewareMode === 'ssr' ? 'custom' : 'spa'),
    experimental: {
      importGlobRestoreExtension: false,
      hmrPartialAccept: false,
      ...config.experimental,
    },
    getSortedPlugins: undefined!,
    getSortedPluginHooks: undefined!,
  }

  const resolved: ResolvedConfig = {
    ...config,
    ...resolvedConfig,
  }

  resolved.plugins = await resolvePlugins(resolved, prePlugins, normalPlugins, postPlugins)

  Object.assign(resolved, createPluginHookUtils(resolved.plugins))

  const workerResolved: ResolvedConfig = {
    ...workerConfig,
    ...resolvedConfig,
    isWorker: true,
    mainConfig: resolved,
  }

  resolvedConfig.worker.plugins = await resolvePlugins(
    workerResolved,
    workerPrePlugins,
    workerNormalPlugins,
    workerPostPlugins,
  )

  Object.assign(resolvedConfig.worker, createPluginHookUtils(resolvedConfig.worker.plugins))

  /**
   * Call configResolved hooks.
   */
  await Promise.all([
    ...resolved.getSortedPluginHooks('configResolved').map((hook) => hook(resolved)),
    ...resolvedConfig.worker
      .getSortedPluginHooks('configResolved')
      .map((hook) => hook(workerResolved)),
  ])

  // validate config

  if (middlewareMode === 'ssr') {
    logger.warn(
      colors.yellow(
        `Setting server.middlewareMode to 'ssr' is deprecated, set server.middlewareMode to \`true\`${
          config.appType === 'custom' ? '' : ` and appType to 'custom'`
        } instead`,
      ),
    )
  }
  if (middlewareMode === 'html') {
    logger.warn(
      colors.yellow(
        `Setting server.middlewareMode to 'html' is deprecated, set server.middlewareMode to \`true\` instead`,
      ),
    )
  }

  if (config.server?.force && !isBuild && config.optimizeDeps?.force === undefined) {
    resolved.optimizeDeps.force = true

    logger.warn(colors.yellow(`server.force is deprecated, use optimizeDeps.force instead`))
  }

  debug?.(`using resolved config: %O`, {
    ...resolved,
    plugins: resolved.plugins.map((p) => p.name),
    worker: {
      ...resolved.worker,
      plugins: resolved.worker.plugins.map((p) => p.name),
    },
  })

  if (config.build?.terserOptions && config.build.minify !== 'terser') {
    logger.warn(
      colors.yellow(
        `build.terserOptions is specified but build.minify is not set to use Terser. ` +
          `Note Vite now defaults to use esbuild for minification. If you still ` +
          `prefer Terser, set build.minify to "terser".`,
      ),
    )
  }

  /**
   * Check if all assetFileNames have the same reference.
   * If not, warn the user.
   */
  const outputOption = config.build?.rollupOptions?.output ?? []

  /**
   * Use {@link Array.isArray} to narrow its type to array.
   */
  if (Array.isArray(outputOption)) {
    const assetFileNamesList = outputOption.map((output) => output.assetFileNames)

    if (assetFileNamesList.length > 1) {
      const firstAssetFileNames = assetFileNamesList[0]
      const hasDifferentReference = assetFileNamesList.some(
        (assetFileNames) => assetFileNames !== firstAssetFileNames,
      )
      if (hasDifferentReference) {
        resolved.logger.warn(
          colors.yellow(
            `assetFileNames isn't equal for every build.rollupOptions.output. A single pattern across all outputs is supported by Vite.`,
          ),
        )
      }
    }
  }

  /**
   * Warn about removal of experimental features.
   */
  if (config.legacy?.buildSsrCjsExternalHeuristics || config.ssr?.format === 'cjs') {
    resolved.logger.warn(
      colors.yellow(`
(!) Experimental legacy.buildSsrCjsExternalHeuristics and ssr.format: 'cjs' are going to be removed in Vite 5. 
    Find more information and give feedback at https://github.com/vitejs/vite/discussions/13816.
`),
    )
  }

  return resolved
}

export interface LoadOptions {
  configEnv: ConfigEnv
  configFile?: string
  root?: string
}

export interface LoadedConfig {
  path: string
  config: UserConfig
  dependencies: string[]
}

export async function loadConfigFromFile(
  options: LoadOptions,
  logLevel?: LogLevel,
): Promise<LoadedConfig | null> {
  const { configEnv, configFile, root = process.cwd() } = options

  const start = performance.now()

  const getTime = () => `${(performance.now() - start).toFixed(2)}ms`

  let resolvedPath: string | undefined

  if (configFile) {
    // explicit config path is always resolved from cwd
    resolvedPath = path.resolve(configFile)
  } else {
    // implicit config file loaded from inline root (if present)
    // otherwise from cwd
    for (const filename of DEFAULT_CONFIG_FILES) {
      const filePath = path.resolve(root, filename)
      if (!fs.existsSync(filePath)) continue

      resolvedPath = filePath
      break
    }
  }

  if (!resolvedPath) {
    debug?.('No config file found.')
    return null
  }

  const isESM = resolveIsESM(resolvedPath, root)

  try {
    const bundled = await bundleConfigFile(resolvedPath, isESM)

    const userConfig = await loadConfigFromBundledFile(resolvedPath, bundled.code, isESM)

    debug?.(`bundled config file loaded in ${getTime()}`)

    const config = await (typeof userConfig === 'function' ? userConfig(configEnv) : userConfig)

    if (!isObject(config)) {
      throw new Error(`config must export or return an object.`)
    }

    return {
      path: normalizePath(resolvedPath),
      config,
      dependencies: bundled.dependencies,
    }
  } catch (e) {
    createLogger(logLevel).error(colors.red(`failed to load config from ${resolvedPath}`), {
      error: e as Error,
    })
    throw e
  }
}

/**
 * @param file Path to file.
 * @param root Root of project to find `package.json`.
 */
function resolveIsESM(file: string, root: string) {
  if (/\.m[jt]s$/.test(file)) {
    return true
  }

  if (/\.c[jt]s$/.test(file)) {
    return false
  }
  // check package.json for type: "module" and set `isESM` to true
  try {
    const pkg = lookupFile(root, ['package.json'])
    return !!pkg && JSON.parse(fs.readFileSync(pkg, 'utf-8')).type === 'module'
  } catch (e) {
    return false
  }
}

export function sortUserPlugins(plugins?: (Plugin | Plugin[])[]): [Plugin[], Plugin[], Plugin[]] {
  if (plugins == null) {
    return [[], [], []]
  }

  const prePlugins = plugins.flat().filter((plugin) => plugin.enforce === 'pre')

  const postPlugins = plugins.flat().filter((plugin) => plugin.enforce === 'post')

  const normalPlugins = plugins
    .flat()
    .filter((plugin) => plugin.enforce !== 'pre' && plugin.enforce !== 'post')

  return [prePlugins, normalPlugins, postPlugins]
}

async function runConfigHook(
  config: InlineConfig,
  plugins: Plugin[],
  configEnv: ConfigEnv,
): Promise<InlineConfig> {
  /**
   * This config will be iterated on by the plugin hooks.
   */
  let currentConfig = config

  for (const plugin of getSortedPluginsBy('config', plugins)) {
    const hook = plugin.config
    const handler = hook && 'handler' in hook ? hook.handler : hook

    if (!handler) {
      continue
    }

    const res = await handler(currentConfig, configEnv)

    if (res) {
      currentConfig = mergeConfig(currentConfig, res)
    }
  }

  return currentConfig
}

/**
 * TODO: move somewhere else.
 */
export function getSortedPluginsBy(key: keyof Plugin, plugins: Plugin[]): Plugin[] {
  const pluginHooks = plugins
    .map((plugin) => ({ plugin, hook: plugin[key] }))
    .filter(({ hook }) => hook != null)

  const pre = pluginHooks
    .filter(({ hook }) => typeof hook === 'object' && hook.order === 'pre')
    .map(({ plugin }) => plugin)

  const post = pluginHooks
    .filter(({ hook }) => typeof hook === 'object' && hook.order === 'post')
    .map(({ plugin }) => plugin)

  const normal = pluginHooks
    .filter(({ hook }) => typeof hook !== 'object')
    .map(({ plugin }) => plugin)

  return [...pre, ...normal, ...post]
}

/**
 * Resolve base url. Note that some users use Vite to build for non-web targets like
 * electron or expects to deploy
 */
export function resolveBaseUrl(
  base: UserConfig['base'] = '/',
  isBuild: boolean,
  logger: Logger,
): string {
  if (base[0] === '.') {
    logger.warn(
      colors.yellow(
        colors.bold(
          `(!) invalid "base" option: ${base}. The value can only be an absolute ` +
            `URL, ./, or an empty string.`,
        ),
      ),
    )
    return '/'
  }

  // external URL flag
  const isExternal = isExternalUrl(base)

  // no leading slash warn
  if (!isExternal && base[0] !== '/') {
    logger.warn(colors.yellow(colors.bold(`(!) "base" option should start with a slash.`)))
  }

  // parse base when command is serve or base is not External URL
  if (!isBuild || !isExternal) {
    base = new URL(base, 'http://vitejs.dev').pathname

    // ensure leading slash
    if (base[0] !== '/') {
      base = '/' + base
    }
  }

  return base
}

export interface BuildOptions {
  /**
   * Compatibility transform target. The transform is performed with esbuild
   * and the lowest supported target is es2015/es6. Note this only handles
   * syntax transformation and does not cover polyfills (except for dynamic
   * import)
   *
   * Default: 'modules' - Similar to `@babel/preset-env`'s targets.esmodules,
   * transpile targeting browsers that natively support dynamic es module imports.
   * https://caniuse.com/es6-module-dynamic-import
   *
   * Another special value is 'esnext' - which only performs minimal transpiling
   * (for minification compat) and assumes native dynamic imports support.
   *
   * For custom targets, see https://esbuild.github.io/api/#target and
   * https://esbuild.github.io/content-types/#javascript for more details.
   * @default 'modules'
   */
  target?: 'modules' | TransformOptions['target'] | false

  /**
   * whether to inject module preload polyfill.
   * Note: does not apply to library mode.
   * @default true
   * @deprecated use `modulePreload.polyfill` instead
   */
  polyfillModulePreload?: boolean
  /**
   * Configure module preload
   * Note: does not apply to library mode.
   * @default true
   */
  modulePreload?: boolean | ModulePreloadOptions
  /**
   * Directory relative from `root` where build output will be placed. If the
   * directory exists, it will be removed before the build.
   * @default 'dist'
   */
  outDir?: string
  /**
   * Directory relative from `outDir` where the built js/css/image assets will
   * be placed.
   * @default 'assets'
   */
  assetsDir?: string
  /**
   * Static asset files smaller than this number (in bytes) will be inlined as
   * base64 strings. Default limit is `4096` (4kb). Set to `0` to disable.
   * @default 4096
   */
  assetsInlineLimit?: number
  /**
   * Whether to code-split CSS. When enabled, CSS in async chunks will be
   * inlined as strings in the chunk and inserted via dynamically created
   * style tags when the chunk is loaded.
   * @default true
   */
  cssCodeSplit?: boolean
  /**
   * An optional separate target for CSS minification.
   * As esbuild only supports configuring targets to mainstream
   * browsers, users may need this option when they are targeting
   * a niche browser that comes with most modern JavaScript features
   * but has poor CSS support, e.g. Android WeChat WebView, which
   * doesn't support the #RGBA syntax.
   * @default target
   */
  cssTarget?: TransformOptions['target'] | false
  /**
   * Override CSS minification specifically instead of defaulting to `build.minify`,
   * so you can configure minification for JS and CSS separately.
   * @default 'esbuild'
   */
  cssMinify?: boolean | 'esbuild' | 'lightningcss'
  /**
   * If `true`, a separate sourcemap file will be created. If 'inline', the
   * sourcemap will be appended to the resulting output file as data URI.
   * 'hidden' works like `true` except that the corresponding sourcemap
   * comments in the bundled files are suppressed.
   * @default false
   */
  sourcemap?: boolean | 'inline' | 'hidden'
  /**
   * Set to `false` to disable minification, or specify the minifier to use.
   * Available options are 'terser' or 'esbuild'.
   * @default 'esbuild'
   */
  minify?: boolean | 'terser' | 'esbuild'
  /**
   * Options for terser
   * https://terser.org/docs/api-reference#minify-options
   */
  terserOptions?: Terser.MinifyOptions

  /**
   * Will be merged with internal rollup options.
   * https://rollupjs.org/configuration-options/
   */
  rollupOptions?: RollupOptions

  /**
   * Options to pass on to `@rollup/plugin-commonjs`
   */
  commonjsOptions?: RollupCommonJSOptions

  /**
   * Options to pass on to `@rollup/plugin-dynamic-import-vars`
   */
  dynamicImportVarsOptions?: RollupDynamicImportVariablesOptions

  /**
   * Whether to write bundle to disk
   * @default true
   */
  write?: boolean
  /**
   * Empty outDir on write.
   * @default true when outDir is a sub directory of project root
   */
  emptyOutDir?: boolean | null
  /**
   * Copy the public directory to outDir on write.
   * @default true
   * @experimental
   */
  copyPublicDir?: boolean
  /**
   * Whether to emit a manifest.json under assets dir to map hash-less filenames
   * to their hashed versions. Useful when you want to generate your own HTML
   * instead of using the one generated by Vite.
   *
   * Example:
   *
   * ```json
   * {
   *   "main.js": {
   *     "file": "main.68fe3fad.js",
   *     "css": "main.e6b63442.css",
   *     "imports": [...],
   *     "dynamicImports": [...]
   *   }
   * }
   * ```
   * @default false
   */
  manifest?: boolean | string
  /**
   * Build in library mode. The value should be the global name of the lib in
   * UMD mode. This will produce esm + cjs + umd bundle formats with default
   * configurations that are suitable for distributing libraries.
   * @default false
   */
  lib?: LibraryOptions | false
  /**
   * Produce SSR oriented build. Note this requires specifying SSR entry via
   * `rollupOptions.input`.
   * @default false
   */
  ssr?: boolean | string
  /**
   * Generate SSR manifest for determining style links and asset preload
   * directives in production.
   * @default false
   */
  ssrManifest?: boolean | string
  /**
   * Emit assets during SSR.
   * @experimental
   * @default false
   */
  ssrEmitAssets?: boolean
  /**
   * Set to false to disable reporting compressed chunk sizes.
   * Can slightly improve build speed.
   * @default true
   */
  reportCompressedSize?: boolean
  /**
   * Adjust chunk size warning limit (in kbs).
   * @default 500
   */
  chunkSizeWarningLimit?: number
  /**
   * Rollup watch options
   * https://rollupjs.org/configuration-options/#watch
   * @default null
   */
  watch?: WatcherOptions | null
}

export interface LibraryOptions {
  /**
   * Path of library entry
   */
  entry: InputOption
  /**
   * The name of the exposed global variable. Required when the `formats` option includes
   * `umd` or `iife`
   */
  name?: string
  /**
   * Output bundle formats
   * @default ['es', 'umd']
   */
  formats?: LibraryFormats[]
  /**
   * The name of the package file output. The default file name is the name option
   * of the project package.json. It can also be defined as a function taking the
   * format as an argument.
   */
  fileName?: string | ((format: ModuleFormat, entryName: string) => string)
}

export type LibraryFormats = 'es' | 'cjs' | 'umd' | 'iife'

export interface ModulePreloadOptions {
  /**
   * Whether to inject a module preload polyfill.
   *
   * Note: does not apply to library mode.
   *
   * @default true
   */
  polyfill?: boolean

  /**
   * Resolve the list of dependencies to preload for a given dynamic import
   *
   * @experimental
   */
  resolveDependencies?: ResolveModulePreloadDependenciesFn
}

export interface ResolvedBuildOptions
  extends Required<Omit<BuildOptions, 'polyfillModulePreload'>> {
  modulePreload: false | ResolvedModulePreloadOptions
}

export interface ResolvedModulePreloadOptions {
  polyfill: boolean
  resolveDependencies?: ResolveModulePreloadDependenciesFn
}

export type ResolveModulePreloadDependenciesFn = (
  filename: string,
  deps: string[],
  context: {
    hostId: string
    hostType: 'html' | 'js'
  },
) => string[]

export function resolveBuildOptions(
  raw: BuildOptions | undefined,
  logger: Logger,
  root: string,
): ResolvedBuildOptions {
  const deprecatedPolyfillModulePreload = raw?.polyfillModulePreload

  if (raw) {
    const { polyfillModulePreload, ...rest } = raw
    raw = rest
    if (deprecatedPolyfillModulePreload !== undefined) {
      logger.warn('polyfillModulePreload is deprecated. Use modulePreload.polyfill instead.')
    }
    if (deprecatedPolyfillModulePreload === false && raw.modulePreload === undefined) {
      raw.modulePreload = { polyfill: false }
    }
  }

  const modulePreload = raw?.modulePreload
  const defaultModulePreload = {
    polyfill: true,
  }

  const defaultBuildOptions: BuildOptions = {
    outDir: 'dist',
    assetsDir: 'assets',
    assetsInlineLimit: 4096,
    cssCodeSplit: !raw?.lib,
    sourcemap: false,
    rollupOptions: {},
    minify: raw?.ssr ? false : 'esbuild',
    terserOptions: {},
    write: true,
    emptyOutDir: null,
    copyPublicDir: true,
    manifest: false,
    lib: false,
    ssr: false,
    ssrManifest: false,
    ssrEmitAssets: false,
    reportCompressedSize: true,
    chunkSizeWarningLimit: 500,
    watch: null,
  }

  const userBuildOptions = raw ? mergeConfig(defaultBuildOptions, raw) : defaultBuildOptions

  // @ts-expect-error Fallback options instead of merging
  const resolved: ResolvedBuildOptions = {
    target: 'modules',
    cssTarget: false,
    ...userBuildOptions,
    commonjsOptions: {
      include: [/node_modules/],
      extensions: ['.js', '.cjs'],
      ...userBuildOptions.commonjsOptions,
    },
    dynamicImportVarsOptions: {
      warnOnError: true,
      exclude: [/node_modules/],
      ...userBuildOptions.dynamicImportVarsOptions,
    },
    // Resolve to false | object
    modulePreload:
      modulePreload === false
        ? false
        : typeof modulePreload === 'object'
        ? {
            ...defaultModulePreload,
            ...modulePreload,
          }
        : defaultModulePreload,
  }

  // handle special build targets
  if (resolved.target === 'modules') {
    resolved.target = ESBUILD_MODULES_TARGET
  } else if (resolved.target === 'esnext' && resolved.minify === 'terser') {
    try {
      const terserPackageJsonPath = requireResolveFromRootWithFallback(root, 'terser/package.json')
      const terserPackageJson = JSON.parse(fs.readFileSync(terserPackageJsonPath, 'utf-8'))
      const v = terserPackageJson.version.split('.')
      if (v[0] === '5' && v[1] < 16) {
        // esnext + terser 5.16<: limit to es2021 so it can be minified by terser
        resolved.target = 'es2021'
      }
    } catch {}
  }

  if (!resolved.cssTarget) {
    resolved.cssTarget = resolved.target
  }

  // normalize false string into actual false
  if ((resolved.minify as string) === 'false') {
    resolved.minify = false
  }

  if (resolved.minify === true) {
    resolved.minify = 'esbuild'
  }

  if (resolved.cssMinify == null) {
    resolved.cssMinify = !!resolved.minify
  }

  return resolved
}
